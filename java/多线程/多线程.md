# 开干
## 创建线程
1. 线程创建方式一 集成Thread类，重写run() 方法，调用start开启线程
* 注意：线程开一不一定要立即执行，由cpu调度执行
2. 线程创建方式一 实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法。
* 启动：传入目标对象+Thread对象.start() 
* 推荐使用：避免单继承的局限性，灵活方柏霓，方便同一个对象被多个线程使用
1. callable 重写call方法
    ``` shell
    ExecutorService ser= Executors.newFixedThreadPool(10);   // 创建执行服务
    Future<Boolean> r1=ser.submit(threadCallable); //            提交执行
    Boolean rs1=r1.get(); // 获获取结果
    ser.shutdownNow(); // 关闭服务
    ```

## 线程方法
1. sleep(1000) 线程延时 不会释放锁
2. yield  线程礼让
3. join 线程插队
4. thread.getState() 获取线程运行状态
5. setPriority getPriority 设置/获取线程优先级 优先级只是意味获取调度的概率低，并不是优先级低就就不被调用，这都是要看cpu的调度
6. setDaemon 守护进程当所有常规线程运行完毕以后，守护线程不管运行到哪里，虚拟机都会退出运行。
## 线程状态
1. NEW 尚未启动的线程在此状态
2. RUNNABLE 在java虚拟机中执行的线程出于状态
3. BLOCKED 被粗赛等待监视器锁定的线程处于状态
4. WAITING 正在等待另一个线程执行特定动作的线程处于状态
5. TIMED_WAITING 正在等待另一个县城执行动作达到指定等待时间的线程处于状态
6. TERMINATED 已退出的线程处于此状态
## 线程数据紊乱
1. synchronized 解决